# -*- coding: utf-8 -*-
"""GenAI for Stock Analyzer and Portfolio Optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z7eobWSHiIQJ32oPhsj9SFeSWZm6D5Ko

# OpenAI API Key
"""

# openai_api_key = "YOUR_OPEN_AI_API_KEY"
# google_api_key="YOUR_GEMINI_API_KEY"
# openrouterai_api_key = "YOUR_OPEN_ROUTER_AI_API_KEY"
groq_api_key = "YOUR_GROQ_API_KEY"

"""# Setup"""

# List of assets to analyze
assets = [
    "Apple (AAPL)",
    "Amazon (AMZN)",
    "Bitcoin (BTC-USD)",
    "Alphabet (GOOGL)",
    "Meta (META)",
    "Microsoft (MSFT)",
    "Nvidia (NVDA)",
    "S&P 500 index (SPY)",
    "Tesla (TSLA)"
]

# Define the start and end years for the analysis
start_year = 2024
end_year = 2025

!pip install langchain-groq

# Import the LangChain Google Gemini Wrapper
# from langchain_google_genai import ChatGoogleGenerativeAI
# from langchain_openai import ChatOpenAI
from langchain_groq import ChatGroq

# Initialize the LLM with Gemini
# llm = ChatGoogleGenerativeAI(
#     model="gemini-2.0-flash-exp",
#     google_api_key=google_api_key,
#     temperature=0.7
# )
# Initialize the LLM with OpenAI (model: gpt-4o-mini)
# llm = ChatOpenAI(
#     model = "gpt-4o-mini",
#     temperature = 0,
#     api_key = api_key
#
# Initialize the LLM with OpenAI (model: llama-3.1-8b)
# llm = ChatOpenAI(
#     model="meta-llama/llama-3.1-8b-instruct:free",
#     openai_api_key=openrouterai_api_key,
#     openai_api_base="https://openrouter.ai/api/v1"
# )
# Initialize the LLM with Groq (model: llama-3.3-70b)
llm = ChatGroq(
    model="llama-3.3-70b-versatile",
    groq_api_key=groq_api_key,
    temperature=0.7
)

# Create the prompt to ask the llm
prompt = f"""
Can you provide a python code snippet using the yfinance library to download stock data.
The tickers are {assets} from {start_year} to {end_year}.
"""

# Use the invoke method to get the response
response = llm.invoke(prompt)

# use the display function from IPython
from IPython.display import display, Markdown

display(Markdown(response.content))

def output(prompt):
  response = llm.invoke(prompt)
  display(Markdown(response.content))

import re
def extract_assets(asset_name):
    """
    Extracts ticker symbol from strings like:
    'Apple (AAPL)' -> 'AAPL'
    'Bitcoin (BTC-USD)' -> 'BTC-USD'
    """
    match = re.search(r'\(([^)]+)\)', asset_name)
    return match.group(1) if match else None

"""# Fetch the stock data"""

# install yfinance
!pip install yfinance

import yfinance as yf
import pandas as pd

# Define the tickers and the time period
tickers = ['AAPL', 'AMZN', 'BTC-USD', 'GOOGL', 'META', 'MSFT', 'NVDA', 'SPY', 'TSLA']
start_date = '2024-01-01'
end_date = '2025-12-31'


# Download the data
data = yf.download(tickers, start=start_date, end=end_date)

# Print the first 5 rows of the downloaded data (Adjusted Close)
# print(data['Adj Close'].head())
data.head()

"""# Top Trading KIPs"""

# Create the prompt for the LLM for the top 10 KPIs
top_10_kpi_prompt = f"""
Tell me the top 10 KPIs I could check for the performance of the stocks, explain what they are and how to interpret.
tickers = {assets}
"""

output(top_10_kpi_prompt)

# Create the prompt for the top 10 KPIs with yfinance
top_10_kpi_with_yfinance_prompt = f"""
  Tell me the top 10 KPIs I could check for the performance of the stocks with data available on yfinance.
  Explain the KPIs and how to interpret them.
  Provide the python code to compute and visualize each of the KPIs.
  Make sure the KPIs can be easily extracted to include in the following prompt for interpretation.
  The structure should be:
  1) What is the KPI and how to interpret
  2) Code snippet for a function to visualize over time for each of the {assets} seperately for each kpi.
  years of analysis are {start_year} to {end_year}.
"""

output(top_10_kpi_with_yfinance_prompt)

"""### Relative Strength Index (RSI)
The RSI is a momentum indicator that measures the magnitude of recent price changes to determine overbought or oversold conditions.

To interpret: An RSI above 70 indicates overbought conditions, while an RSI below 30 indicates oversold conditions.

"""

import yfinance as yf
import matplotlib.pyplot as plt

def plot_rsi(ticker):
    stock = yf.Ticker(ticker)
    hist = stock.history(start='2024-01-01', end='2025-12-31')
    delta = hist['Close'].diff()
    up, down = delta.copy(), delta.copy()
    up[up < 0] = 0
    down[down > 0] = 0
    roll_up = up.rolling(window=14).mean()
    roll_down = down.rolling(window=14).mean().abs()
    RS = roll_up / roll_down
    RSI = 100.0 - (100.0 / (1.0 + RS))
    RSI.plot()
    plt.title(f'RSI for {ticker}')
    plt.xlabel('Date')
    plt.ylabel('RSI')
    plt.axhline(y=30, color='r', linestyle='--')
    plt.axhline(y=70, color='g', linestyle='--')
    plt.show()

for ticker in assets:
    asset_name = extract_assets(ticker)
    plot_rsi(asset_name)

"""### Bollinger
Bollinger Bands measure volatility by plotting two standard deviations above and below a moving average. Interpretation: A rising upper band indicates increasing volatility, while a falling lower band indicates decreasing volatility.
"""

def plot_bollinger_bands(ticker):
    stock = yf.Ticker(ticker)
    hist = stock.history(start='2024-01-01', end='2025-12-31')
    hist['MA_20'] = hist['Close'].rolling(window=20).mean()
    hist['Upper_BB'] = hist['MA_20'] + 2*hist['Close'].rolling(window=20).std()
    hist['Lower_BB'] = hist['MA_20'] - 2*hist['Close'].rolling(window=20).std()
    hist[['Close', 'MA_20', 'Upper_BB', 'Lower_BB']].plot()
    plt.title(f'Bollinger Bands for {ticker}')
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.show()

for ticker in assets:
    asset_name = extract_assets(ticker)
    plot_bollinger_bands(asset_name)

"""### Moving Average Convergence Divergence (MACD)
MACD measures the difference between two moving averages to identify trends and predict price movements. Interpretation: A rising MACD line indicates a bullish trend, while a falling MACD line indicates a bearish trend.
"""

def plot_macd(ticker):
    stock = yf.Ticker(ticker)
    hist = stock.history( start='2024-01-01', end='2025-12-31')
    hist['MA_12'] = hist['Close'].ewm(span=12, adjust=False).mean()
    hist['MA_26'] = hist['Close'].ewm(span=26, adjust=False).mean()
    hist['MACD'] = hist['MA_12'] - hist['MA_26']
    hist['Signal'] = hist['MACD'].ewm(span=9, adjust=False).mean()
    hist[['MACD', 'Signal']].plot()
    plt.title(f'MACD for {ticker}')
    plt.xlabel('Date')
    plt.ylabel('MACD')
    plt.show()

for ticker in assets:
    asset_name = extract_assets(ticker)
    plot_macd(asset_name)

"""### P/E Ratio"""

def compare_pe_ratios(assets):
    data = []

    for asset in assets:
        ticker = extract_assets(asset)
        if ticker is None:
            continue

        stock = yf.Ticker(ticker)
        info = stock.info

        pe = info.get("trailingPE")

        data.append({
            "Asset": asset,
            "Ticker": ticker,
            "PE Ratio": pe
        })

    df = pd.DataFrame(data)

    # Remove assets with missing PE (e.g., crypto, loss-making firms)
    df = df.dropna(subset=["PE Ratio"])

    # Sort by PE ratio
    df = df.sort_values(by="PE Ratio")

    # Plot
    plt.figure(figsize=(10, 5))
    plt.barh(df["Ticker"], df["PE Ratio"])
    plt.xlabel("P/E Ratio")
    plt.title("P/E Ratio Comparison")
    plt.show()

    return df

compare_pe_ratios(assets)

"""### Beta"""

def compare_beta(assets):
    beta_data = []

    for asset in assets:
        ticker = extract_assets(asset)
        if ticker is None:
            continue

        stock = yf.Ticker(ticker)
        info = stock.info

        beta = info.get("beta")  # 5Y Monthly Beta

        beta_data.append({
            "Asset": asset,
            "Ticker": ticker,
            "Beta": beta
        })

    df = pd.DataFrame(beta_data)

    # Drop assets with no beta (e.g., crypto)
    df = df.dropna(subset=["Beta"])

    # Sort by beta for better visualization
    df = df.sort_values(by="Beta")

    # Plot bar chart
    plt.figure(figsize=(10, 5))
    plt.bar(df["Ticker"], df["Beta"])
    plt.axhline(1, linestyle="--", label="Market Beta = 1")
    plt.xlabel("Asset")
    plt.ylabel("Beta")
    plt.title("Beta Comparison of Assets")
    plt.legend()
    plt.show()

    return df

compare_beta(assets)

"""### Storing KPIs"""

kpi_store = {}

for asset in assets:
    ticker = extract_assets(asset)
    if ticker is None:
        continue

    stock = yf.Ticker(ticker)

    # ---------- Price-based KPIs ----------
    hist = stock.history(start="2024-01-01", end="2025-12-31")
    if hist.empty:
        continue

    close = hist["Close"]

    # RSI (14)
    delta = close.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(14).mean()
    avg_loss = loss.rolling(14).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    latest_rsi = rsi.iloc[-1]

    # Bollinger Bands (20)
    ma20 = close.rolling(20).mean()
    std20 = close.rolling(20).std()
    upper_bb = ma20 + 2 * std20
    lower_bb = ma20 - 2 * std20

    latest_bb = {
        "MA20": ma20.iloc[-1],
        "Upper": upper_bb.iloc[-1],
        "Lower": lower_bb.iloc[-1]
    }

    # MACD (12, 26, 9)
    ema12 = close.ewm(span=12, adjust=False).mean()
    ema26 = close.ewm(span=26, adjust=False).mean()
    macd = ema12 - ema26
    signal = macd.ewm(span=9, adjust=False).mean()

    latest_macd = {
        "MACD": macd.iloc[-1],
        "Signal": signal.iloc[-1]
    }

    # ---------- Fundamental KPIs ----------
    info = stock.info
    pe_ratio = info.get("trailingPE")
    beta = info.get("beta")

    # ---------- Store KPIs ----------
    kpi_store[ticker] = {
        "RSI_14": latest_rsi,
        "Bollinger": latest_bb,
        "MACD": latest_macd,
        "PE_Ratio": pe_ratio,
        "Beta": beta
    }

# kpi_store now contains all KPIs for each asset
print(kpi_store)

summary_prompt = f"""
  Read this data {kpi_store} and provide an executive summary with recommendation
"""
output(summary_prompt)

"""If you have an error with the token limit (or you want to save on tokens) Ask previously to aggregate the data on a monthly level.

# Modern Portfolio Theory
"""

risk_free_rate = 0.04

mpt_prompt = f"""
  Explain what is the Modern Portfolio Theory, with a risk free rate of {risk_free_rate}.
  Provide the Python code snippets for the MPT for the following {assets} for the years {start_year} and {end_year}
  Print the weights with 2 decimal cases. Store the results in a dictionary with the tickers
  as key and the weights as value.
"""
output(mpt_prompt)

import numpy as np
from datetime import datetime, timedelta
from scipy.optimize import minimize

# Define the tickers and risk-free rate
tickers = ['AAPL', 'AMZN', 'BTC-USD', 'GOOGL', 'META', 'MSFT', 'NVDA', 'SPY', 'TSLA']
risk_free_rate = 0.04

# Define the time period
start_date = datetime(2024, 1, 1)
end_date = datetime(2025, 12, 31)

# Download the data
data = yf.download(tickers, start=start_date, end=end_date,  auto_adjust=False)['Adj Close']

# Calculate the returns
returns = data.pct_change().dropna()

# Calculate the expected returns and covariances
expected_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252

# Calculate the efficient frontier
from scipy.optimize import minimize

def neg_sharpe_ratio(weights):
    portfolio_return = np.sum(expected_returns * weights)
    portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_volatility
    return -sharpe_ratio

n_assets = len(tickers)
weights_init = np.array([1.0 / n_assets] * n_assets)

# Constraints: weights must sum to 1
constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
bounds = tuple((0, 1) for _ in range(n_assets))

result = minimize(neg_sharpe_ratio, weights_init, method='SLSQP', bounds=bounds, constraints=constraints)

# Print the weights
weights = result.x
weights_dict = {ticker: round(weight, 2) for ticker, weight in zip(tickers, weights)}
print(weights_dict)

alt_optimization_prompt = f"""
This is the portfolio allocation {weights_dict} from the MPT for the following {assets}. Give me
5 different portfolio optimization techniques to optimize the portfolio and explain the pros and cons
 of each alternative and how it differs from the MPT.
"""
output(alt_optimization_prompt)

"""# The Black-Litterman Model

Assumption: Microsoft will outperform Google by 5%
"""

!pip install PyPortfolioOpt

from pypfopt import risk_models, expected_returns, BlackLittermanModel, EfficientFrontier, black_litterman

risk_free_rate = 0.001

# Download historical data
df = yf.download(tickers, start=start_date, end=end_date, auto_adjust=False)['Adj Close']
df.head(1)

# Calculate the Sample Mean Returns and the Covariance Matrix
mu = expected_returns.mean_historical_return(df)
S = risk_models.sample_cov(df)

# Market Capitalization
mcap = {}
for ticker in tickers:
  stock = yf.Ticker(ticker)
  try:
    mcap[ticker] = stock.info['marketCap']
  except KeyError:
    mcap[ticker] = None

mcap

# Define ours beliefs (Assumption)
Q = np.array([0.05]) # Microsoft beats Google by 5%
print(Q)
P = np.zeros((1, len(tickers))) # I used tickers instead of assets beacuse tickers have short name only where assets needs to extract asset name
print(P)
P[0, tickers.index('MSFT')] = 1
P[0, tickers.index('GOOGL')] = -1
print(P)

# Calculate the market implied returns
market_prices = df["SPY"]
delta = black_litterman.market_implied_risk_aversion(market_prices)
market_prior = black_litterman.market_implied_prior_returns(mcap, delta, S, risk_free_rate)

# Create the Black Litterman Model
bl = BlackLittermanModel(S, Q = Q, P = P, pi = market_prior, market_weights = market_prior, risk_free_rate = risk_free_rate)

# Get the returns and covariance
bl_returns = bl.bl_returns()
print(bl_returns)
bl_cov = bl.bl_cov()

# Optimize the portfolio
ef = EfficientFrontier(bl_returns, bl_cov)
weights = ef.max_sharpe(risk_free_rate = risk_free_rate)
cleaned_weights = ef.clean_weights()
print(cleaned_weights)

ef.portfolio_performance(verbose=True)

